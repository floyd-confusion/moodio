<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Player - Music Recommendation</title>
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Custom CSS -->
    <link href="/styles.css" rel="stylesheet">
    
    <style>
        /* Custom styles specific to embed page */
        .player-container {
            margin: 4rem 0;
            border-radius: 16px;
            overflow: hidden;
        }
        .back-button {
            background-color: #1DB954;
            color: white;
            border: none;
            padding: 1rem 2rem;
            font-size: 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-bottom: 2rem;
        }
        .back-button:hover {
            background-color: #1ed760;
        }
        .adjustment-buttons {
            display: flex;
            gap: 2rem;
            margin: 4rem 0;
            justify-content: center;
        }
        .adjust-button {
            background-color: #f8f8f8;
            border: 4px solid;
            padding: 1.5rem 3rem;
            font-size: 2.5rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 1rem;
            min-width: 150px;
            justify-content: center;
        }
        .adjust-button.more {
            border-color: #1DB954;
            color: #1DB954;
        }
        .adjust-button.more:hover {
            background-color: #1DB954;
            color: white;
        }
        .adjust-button.less {
            border-color: #e74c3c;
            color: #e74c3c;
        }
        .adjust-button.less:hover {
            background-color: #e74c3c;
            color: white;
        }
        .like-button {
            background: linear-gradient(135deg, var(--color-paper), #F2F0E5);
            border: 2px solid var(--color-orange);
            color: var(--color-orange);
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 500;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(188, 82, 21, 0.2);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            min-width: 120px;
            justify-content: center;
        }
        .like-button:hover {
            transform: translateY(-2px);
            background: linear-gradient(135deg, var(--color-orange), var(--color-orange-light));
            border-color: var(--color-orange-light);
            color: white;
            box-shadow: 0 6px 18px rgba(188, 82, 21, 0.4);
        }
        .like-button:active {
            transform: translateY(0);
        }
        .like-button.liked {
            background: linear-gradient(135deg, var(--color-orange), var(--color-orange-light));
            border-color: var(--color-orange-light);
            color: white;
            box-shadow: 0 6px 18px rgba(188, 82, 21, 0.4);
        }
        .liked-tracks-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .liked-track-item {
            padding: 0.75rem;
            border-bottom: 1px solid #ddd;
            font-size: 0.9rem;
            color: #666;
            transition: background-color 0.2s;
        }
        .liked-track-item:hover {
            background-color: #f8f8f8;
        }
        .liked-track-item:last-child {
            border-bottom: none;
        }
        .info-card {
            background-color: #f8f8f8;
            border-radius: 16px;
            padding: 2rem;
            margin-top: 4rem;
        }
        .info-title {
            font-size: 2rem;
            color: #333;
            margin-bottom: 2rem;
            border-bottom: 4px solid #1DB954;
            padding-bottom: 1rem;
        }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
        }
        .info-item {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .info-label {
            font-size: 1.2rem;
            color: #666;
        }
        .info-value {
            font-size: 1.4rem;
            color: #333;
            font-weight: 500;
        }
        .button-container {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .user-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: white;
            padding: 1rem 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .back-arrow {
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 1001;
            background: var(--color-orange);
            color: white;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(188, 82, 21, 0.3);
        }

        .back-arrow:hover {
            background: var(--color-orange-light);
            transform: translateY(-2px);
            box-shadow: 0 6px 18px rgba(188, 82, 21, 0.4);
        }

        .back-arrow:active {
            transform: translateY(0);
        }
        
        .user-info {
            color: #666;
            font-size: 0.9rem;
        }
        
        .user-name {
            font-weight: 600;
            color: #1DB954;
        }
        
        .auth-link, .logout-btn {
            color: #1DB954;
            text-decoration: none;
            font-size: 0.9rem;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
        }
        
        .auth-link:hover, .logout-btn:hover {
            text-decoration: underline;
        }

        .filter-button {
            background: linear-gradient(135deg, var(--color-orange), #FF6B35);
            border: none;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 25px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(188, 82, 21, 0.3);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            min-width: 120px;
            justify-content: center;
        }

        .filter-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 18px rgba(188, 82, 21, 0.4);
            background: linear-gradient(135deg, #C55614, #E55A2B);
        }

        .filter-button:active {
            transform: translateY(0);
        }

        .filter-button-emoji {
            font-size: 1.1rem;
        }

        #filterButtonsSection {
            animation: fadeInUp 0.6s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Sidebar Styles */
        .liked-tracks-sidebar {
            background: var(--color-paper);
            border-left: 2px solid var(--color-200);
            padding: 1.5rem;
            height: calc(100vh - 100px);
            overflow-y: auto;
            position: sticky;
            top: 100px;
        }

        .sidebar-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--color-900);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--color-orange);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .liked-tracks-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .liked-track-item {
            background: var(--color-50);
            border: 1px solid var(--color-200);
            border-radius: 8px;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            font-size: 0.85rem;
            color: var(--color-800);
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .liked-track-item:hover {
            background: var(--color-100);
            border-color: var(--color-orange);
            transform: translateX(2px);
        }

        .liked-track-item:last-child {
            margin-bottom: 0;
        }

        .track-name {
            font-weight: 600;
            color: var(--color-900);
            margin-bottom: 0.25rem;
        }

        .track-artist {
            color: var(--color-600);
            font-size: 0.8rem;
        }

        .empty-likes, .empty-filters {
            text-align: center;
            color: var(--color-500);
            font-style: italic;
            padding: 2rem 1rem;
        }

        .session-filters-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .session-filter-item {
            background: var(--color-50);
            border: 1px solid var(--color-200);
            border-radius: 8px;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            font-size: 0.85rem;
            color: var(--color-800);
            transition: all 0.2s ease;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            justify-content: space-between;
        }

        .session-filter-item:hover {
            background: var(--color-100);
            border-color: var(--color-red);
            transform: translateX(2px);
        }

        .session-filter-item:last-child {
            margin-bottom: 0;
        }

        .filter-content {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
        }

        .filter-emoji {
            font-size: 1.2em;
        }

        .filter-text {
            font-weight: 500;
            color: var(--color-900);
            flex: 1;
        }

        .filter-time {
            color: var(--color-600);
            font-size: 0.75rem;
        }

        .delete-filter-btn {
            background: none;
            border: none;
            color: var(--color-red);
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 1rem;
            line-height: 1;
        }

        .session-filter-item:hover .delete-filter-btn {
            opacity: 1;
        }

        .delete-filter-btn:hover {
            background: var(--color-red);
            color: white;
        }

        .bg-orange {
            background-color: var(--color-orange) !important;
        }

        .sidebar-toggle {
            display: none;
        }

        @media (max-width: 1199px) {
            .liked-tracks-sidebar {
                display: none;
            }

            .sidebar-toggle {
                display: inline-block;
                background: var(--color-orange);
                color: white;
                border: none;
                padding: 0.5rem 1rem;
                border-radius: 20px;
                font-size: 0.9rem;
                cursor: pointer;
                margin-left: 1rem;
            }
        }

        /* Toggle Switch Styles */
        .playback-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            margin: 0;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #FF0000; /* YouTube Red */
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        .toggle-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: #333;
        }
    </style>
</head>
<body>
    <!-- Back Button -->
    <button class="back-arrow" onclick="window.location.href='/sessions'" title="Back to Session Selection">
        ←
    </button>

    <!-- User Header -->
    <nav class="user-header">
        <div class="container-fluid">
            <div class="d-flex justify-content-end align-items-center">
                <button class="sidebar-toggle" onclick="toggleSidebar()">
                    ❤️ Liked Tracks
                </button>
                <div class="playback-toggle ms-3">
                    <label class="toggle-switch">
                        <input type="checkbox" id="playbackToggle" onchange="togglePlaybackType()">
                        <span class="toggle-slider"></span>
                    </label>
                    <span class="toggle-label">YouTube</span>
                </div>
                <div id="userHeader" class="ms-3">
                    <!-- User info will be added here by JavaScript -->
                </div>
            </div>
        </div>
    </nav>
    
    <!-- Main Content -->
    <div class="container-fluid" style="padding-top: 6rem; padding-bottom: 2rem;">
        <div class="row">
            <div class="col-12 col-xl-8 col-lg-7">
                <!-- Current Track Info -->
                <div class="text-center mb-4">
                    <div class="track-info-container bg-white bg-opacity-50 rounded-4 p-4 mb-4" id="currentTrackInfo">
                        <!-- Current track info will be populated here -->
                    </div>
                </div>
                
                <!-- Music Player -->
                <div class="text-center mb-4">
                    <div class="player-container bg-white bg-opacity-30 rounded-4 p-3">
                        <!-- Spotify Player -->
                        <iframe id="spotifyEmbed"
                                width="100%"
                                height="380"
                                frameborder="0"
                                allowfullscreen=""
                                allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"
                                loading="lazy"
                                class="rounded-3"
                                style="display: none;">
                        </iframe>

                        <!-- YouTube Player -->
                        <iframe id="youtubeEmbed"
                                width="560"
                                height="315"
                                title="YouTube video player"
                                frameborder="0"
                                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                                referrerpolicy="no-referrer-when-downgrade"
                                allowfullscreen></iframe>
                    </div>
                </div>
                
                <!-- Audio Features -->
                <div class="text-center">
                    <div class="audio-features-container bg-white bg-opacity-30 rounded-4 p-4">
                        <div class="audio-dials-container" id="audioDialsContainer">
                            <!-- Audio feature dials will be populated here -->
                        </div>
                    </div>
                </div>
                
                <!-- Filter Buttons -->
                <div class="text-center mt-4" id="filterButtonsSection" style="display: none;">
                    <h5 class="mb-3 text-music">✨ Adjust Your Vibe</h5>
                    <div id="filterButtonsContainer" class="d-flex justify-content-center gap-3 flex-wrap">
                        <!-- Filter buttons will be populated here -->
                    </div>
                </div>

                <!-- Track Actions -->
                <div class="text-center mt-4">
                    <div class="d-flex justify-content-center gap-3 flex-wrap">
                        <button class="like-button" id="likeButton" onclick="toggleLike()">
                            ❤️ Like This Track
                        </button>
                        <button class="btn btn-music btn-lg px-4" id="nextButton" onclick="loadInitialTrack()">
                            Next Track
                        </button>
                    </div>
                </div>
            </div>

            <!-- Liked Tracks Sidebar -->
            <div class="col-xl-4 col-lg-5 d-none d-lg-block">
                <div class="liked-tracks-sidebar">
                    <div class="sidebar-title">
                        ❤️ Liked Tracks
                        <span class="badge bg-orange ms-auto" id="likedTracksCount">0</span>
                    </div>
                    <ul class="liked-tracks-list" id="likedTracksList">
                        <li class="empty-likes">No liked tracks yet</li>
                    </ul>

                    <!-- Session Filters Section -->
                    <div class="sidebar-title mt-4">
                        🎛️ Applied Filters
                        <span class="badge bg-orange ms-auto" id="filtersCount">0</span>
                    </div>
                    <ul class="session-filters-list" id="sessionFiltersList">
                        <li class="empty-filters">No filters applied yet</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Filter controls have been extracted to filter-controls.html for later restoration -->
    </div>
    
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        let currentTrackId = null;
        let likedTracks = new Set();
        let currentUser = null;

        // Music filters with emoji mapping (using same emojis as audio dials)
        const musicFilters = {
            "Let's get groovy": { filter: "filter_increase_danceability", emoji: "💃" },
            "Take the groove down": { filter: "filter_decrease_danceability", emoji: "💃" },
            "Crank up the energy": { filter: "filter_increase_energy", emoji: "⚡" },
            "Keep it chill": { filter: "filter_decrease_energy", emoji: "⚡" },
            "Talk to me — more lyrics": { filter: "filter_increase_speechiness", emoji: "🗣️" },
            "Less chatter, more vibe": { filter: "filter_decrease_speechiness", emoji: "🗣️" },
            "Make it happier": { filter: "filter_increase_valence", emoji: "😊" },
            "Go darker, moodier": { filter: "filter_decrease_valence", emoji: "😊" },
            "Pick up the pace": { filter: "filter_increase_tempo", emoji: "🥁" },
            "Slow it down": { filter: "filter_decrease_tempo", emoji: "🥁" },
            "More acoustic vibes": { filter: "filter_progressive_increase_acousticness", emoji: "🎸" },
            "Less acoustic please": { filter: "filter_progressive_decrease_acousticness", emoji: "🎸" },
            "Go instrumental": { filter: "filter_progressive_increase_instrumentalness", emoji: "🎼" },
            "Need more vocals": { filter: "filter_progressive_decrease_instrumentalness", emoji: "🎼" },
            "Live concert feel": { filter: "filter_progressive_increase_liveness", emoji: "🎤" },
            "Studio perfection": { filter: "filter_progressive_decrease_liveness", emoji: "🎤" }
        };

        // Create reverse lookup from filter name to display text and emoji
        const filterMapping = {};
        Object.keys(musicFilters).forEach(displayName => {
            const filterData = musicFilters[displayName];
            filterMapping[filterData.filter] = {
                displayName: displayName,
                emoji: filterData.emoji
            };
        });

        function getRandomFilters(count = 3) {
            /**
             * Select random filters from the music filters object
             *
             * Args:
             *     count (int): Number of random filters to select
             *
             * Returns:
             *     Array: Array of filter objects with name, filter, and emoji
             */
            const filterNames = Object.keys(musicFilters);
            const selected = [];
            const used = new Set();

            while (selected.length < count && selected.length < filterNames.length) {
                const randomIndex = Math.floor(Math.random() * filterNames.length);
                const filterName = filterNames[randomIndex];

                if (!used.has(filterName)) {
                    used.add(filterName);
                    selected.push({
                        name: filterName,
                        filter: musicFilters[filterName].filter,
                        emoji: musicFilters[filterName].emoji
                    });
                }
            }

            return selected;
        }

        function renderFilterButtons() {
            /**
             * Render three random filter buttons on the page after a track is shown
             */
            const filtersContainer = document.getElementById('filterButtonsContainer');
            const filtersSection = document.getElementById('filterButtonsSection');

            const randomFilters = getRandomFilters(3);

            // Clear existing buttons
            filtersContainer.innerHTML = '';

            // Create buttons for each random filter
            randomFilters.forEach(filter => {
                const button = document.createElement('button');
                button.className = 'filter-button';
                button.innerHTML = `
                    <span class="filter-button-emoji">${filter.emoji}</span>
                    <span>${filter.name}</span>
                `;
                button.onclick = () => applyFilter(filter.filter);
                filtersContainer.appendChild(button);
            });

            // Show the filters section
            filtersSection.style.display = 'block';
        }

        async function applyFilter(filterName) {
            /**
             * Apply a specific filter and load the next track
             *
             * Args:
             *     filterName (string): The filter function name to apply
             */
            if (!currentUser) {
                console.error('No user authenticated for filter application');
                return;
            }

            try {
                // Get current session ID from the backend
                const sessionResponse = await fetch(`/api/user/${currentUser.id}/sessions/current`);
                const sessionData = await sessionResponse.json();

                if (!sessionData.current_session || !sessionData.current_session.id) {
                    throw new Error('No active session found');
                }

                const sessionId = sessionData.current_session.id;

                // Hide filter buttons while processing
                document.getElementById('filterButtonsSection').style.display = 'none';

                // Apply the named filter via session's add_filter method
                const response = await fetch(`/api/user/${currentUser.id}/sessions/${sessionId}/filters`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ filter_type: filterName })
                });

                const result = await response.json();

                if (result.error) {
                    throw new Error(result.error);
                }

                // Load a new track after applying the filter
                loadInitialTrack();

                // Reload the session filters list
                loadSessionFilters();

            } catch (error) {
                console.error('Error applying filter:', error);
                alert('Error applying filter. Please try again.');
                // Re-show filter buttons on error
                document.getElementById('filterButtonsSection').style.display = 'block';
            }
        }

        function updateLikeButton() {
            const likeButton = document.getElementById('likeButton');
            if (likeButton) {
                if (likedTracks.has(currentTrackId)) {
                    likeButton.classList.add('liked');
                } else {
                    likeButton.classList.remove('liked');
                }
            }
        }

        async function toggleLike() {
            if (!currentTrackId || !currentUser) return;

            try {
                // Get current session to get the session ID
                const sessionResponse = await fetch(`/api/user/${currentUser.id}/sessions/current`);
                const sessionData = await sessionResponse.json();

                if (!sessionData.current_session) {
                    throw new Error('No active session found');
                }

                const sessionId = sessionData.current_session.id;

                const response = await fetch(`/api/user/${currentUser.id}/sessions/${sessionId}/likes`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ track_id: currentTrackId })
                });

                const result = await response.json();

                if (!result.error) {
                    // Update the liked tracks set based on server response
                    if (result.was_new) {
                        likedTracks.add(currentTrackId);
                    }
                    // Note: Since we only have add functionality, we don't remove from the set
                    updateLikeButton();
                    loadLikedTracks();
                } else {
                    console.error('Error toggling like:', result.error);
                }
            } catch (error) {
                console.error('Error toggling like:', error);
            }
        }

        function loadAdjustmentHistory() {
            fetch('/api/adjustment_history')
                .then(response => response.json())
                .then(data => {
                    const historyTable = document.getElementById('adjustmentHistoryTable');
                    const adjustments = data.adjustments || [];
                    
                    if (adjustments.length === 0) {
                        historyTable.innerHTML = '<tr><td colspan="10" style="text-align: center; color: #666; font-style: italic;">No adjustments made yet</td></tr>';
                        return;
                    }
                    
                    // Map adjustment IDs to readable format
                    const paramMap = {
                        0: 'Danceability ↓', 1: 'Danceability ↑',
                        2: 'Energy ↓', 3: 'Energy ↑', 
                        4: 'Speechiness ↓', 5: 'Speechiness ↑',
                        6: 'Valence ↓', 7: 'Valence ↑',
                        8: 'Tempo ↓', 9: 'Tempo ↑',
                        10: 'Acousticness Progressive ↑', 11: 'Acousticness Progressive ↓',
                        12: 'Instrumentalness Progressive ↑', 13: 'Instrumentalness Progressive ↓',
                        14: 'Liveness Progressive ↑', 15: 'Liveness Progressive ↓'
                    };
                    
                    historyTable.innerHTML = adjustments.map((adj, index) => {
                        const time = new Date(adj.timestamp).toLocaleTimeString();
                        const adjustmentText = paramMap[adj.adjustment_id] || `${adj.parameter} ${adj.direction}`;
                        const poolBefore = adj.pool_size_before ? adj.pool_size_before.toLocaleString() : 'N/A';
                        const poolAfter = adj.pool_size_after ? adj.pool_size_after.toLocaleString() : 'N/A';
                        
                        // Get average stats after the adjustment
                        const stats = adj.avg_stats_after || {};
                        const dance = stats.danceability ? stats.danceability.toFixed(3) : 'N/A';
                        const energy = stats.energy ? stats.energy.toFixed(3) : 'N/A';
                        const speech = stats.speechiness ? stats.speechiness.toFixed(3) : 'N/A';
                        const valence = stats.valence ? stats.valence.toFixed(3) : 'N/A';
                        const tempo = stats.tempo ? Math.round(stats.tempo) : 'N/A';
                        
                        return `
                            <tr>
                                <td>${index + 1}</td>
                                <td>${adjustmentText}</td>
                                <td>${time}</td>
                                <td>${poolBefore}</td>
                                <td>${poolAfter}</td>
                                <td>${dance}</td>
                                <td>${energy}</td>
                                <td>${speech}</td>
                                <td>${valence}</td>
                                <td>${tempo}</td>
                            </tr>
                        `;
                    }).join('');
                })
                .catch(error => {
                    console.error('Error loading adjustment history:', error);
                    document.getElementById('adjustmentHistoryTable').innerHTML = 
                        '<tr><td colspan="10" style="text-align: center; color: #e74c3c;">Error loading history</td></tr>';
                });
        }

        function loadPoolStats() {
            fetch('/api/pool_stats')
                .then(response => response.json())
                .then(stats => {
                    const poolStatsDiv = document.getElementById('poolStats');
                    poolStatsDiv.innerHTML = `
                        <div style="margin-bottom: 0.5rem;"><strong>Total DB:</strong> ${stats.total_tracks.toLocaleString()}</div>
                        <div style="margin-bottom: 0.5rem;"><strong>Genre Pool:</strong> ${stats.genre_pool_size.toLocaleString()}</div>
                        <div style="margin-bottom: 0.5rem;"><strong>Playback Pool:</strong> ${stats.playback_pool_size.toLocaleString()}</div>
                        <div style="margin-bottom: 0.5rem;"><strong>Filters Applied:</strong> ${stats.filters_applied}</div>
                        <div style="margin-bottom: 0.5rem;"><strong>Tracks Shown:</strong> ${stats.tracks_shown || 0}</div>
                        <div style="margin-bottom: 0.5rem;"><strong>Reduction:</strong> ${stats.pool_reduction_pct}%</div>
                        <hr style="margin: 0.5rem 0; border-color: #999;">
                        <div style="font-size: 0.8rem; color: #666;">
                            <div><strong>Avg Pool Features:</strong></div>
                            <div>Dance: ${stats.avg_stats.danceability || 'N/A'}</div>
                            <div>Energy: ${stats.avg_stats.energy || 'N/A'}</div>
                            <div>Speech: ${stats.avg_stats.speechiness || 'N/A'}</div>
                            <div>Valence: ${stats.avg_stats.valence || 'N/A'}</div>
                            <div>Tempo: ${stats.avg_stats.tempo || 'N/A'}</div>
                            <div>Acoustic: ${stats.avg_stats.acousticness || 'N/A'}</div>
                            <div>Instrumental: ${stats.avg_stats.instrumentalness || 'N/A'}</div>
                            <div>Liveness: ${stats.avg_stats.liveness || 'N/A'}</div>
                        </div>
                    `;
                })
                .catch(error => {
                    console.error('Error loading pool stats:', error);
                    document.getElementById('poolStats').innerHTML = '<div style="color: #e74c3c;">Error loading stats</div>';
                });
        }

        function resetPool() {
            if (!confirm('Reset pool to original state? This will clear all adjustments.')) {
                return;
            }
            
            fetch('/api/clear_adjustments', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(result => {
                if (!result.error) {
                    loadPoolStats();
                    loadAdjustmentHistory();
                    // Load a new track from the reset pool
                    loadInitialTrack();
                } else {
                    alert('Error resetting pool: ' + result.error);
                }
            })
            .catch(error => {
                console.error('Error resetting pool:', error);
                alert('Error resetting pool');
            });
        }

        async function loadLikedTracks() {
            if (!currentUser) return;

            try {
                // Get current session to get the session ID
                const sessionResponse = await fetch(`/api/user/${currentUser.id}/sessions/current`);
                const sessionData = await sessionResponse.json();

                if (!sessionData.current_session) {
                    console.log('No active session found for loading liked tracks');
                    return;
                }

                const sessionId = sessionData.current_session.id;

                // Get liked tracks for this session
                const response = await fetch(`/api/user/${currentUser.id}/sessions/${sessionId}/likes`);
                const data = await response.json();

                if (data.error) {
                    console.error('Error loading liked tracks:', data.error);
                    return;
                }

                likedTracks = new Set(data.liked_tracks || []);
                updateLikeButton();

                // Update likes count badge
                const likedTracksCount = document.getElementById('likedTracksCount');
                if (likedTracksCount) {
                    likedTracksCount.textContent = likedTracks.size;
                }

                const likedTracksList = document.getElementById('likedTracksList');
                if (likedTracksList) {
                    likedTracksList.innerHTML = '';

                    if (likedTracks.size === 0) {
                        likedTracksList.innerHTML = '<li class="empty-likes">No liked tracks yet</li>';
                        return;
                    }

                    // Get track details for each liked track
                    Promise.all(Array.from(likedTracks).map(trackId =>
                        fetch(`/api/track/${trackId}`)
                            .then(response => response.json())
                            .catch(() => null)
                    ))
                    .then(tracks => {
                        tracks.filter(track => track).forEach(track => {
                            const li = document.createElement('li');
                            li.className = 'liked-track-item';
                            li.innerHTML = `
                                <div class="track-name">${track.track_name}</div>
                                <div class="track-artist">${track.artist_name}</div>
                            `;
                            likedTracksList.appendChild(li);
                        });
                    });
                }
            } catch (error) {
                console.error('Error loading liked tracks:', error);
            }
        }

        async function loadSessionFilters() {
            if (!currentUser) return;

            try {
                // Get current session to get the session ID
                const sessionResponse = await fetch(`/api/user/${currentUser.id}/sessions/current`);
                const sessionData = await sessionResponse.json();

                if (!sessionData.current_session) {
                    console.log('No active session found for loading session filters');
                    return;
                }

                const sessionId = sessionData.current_session.id;

                // Get filters for this session
                const response = await fetch(`/api/user/${currentUser.id}/sessions/${sessionId}/filters`);
                const data = await response.json();

                if (data.error) {
                    console.error('Error loading session filters:', data.error);
                    return;
                }

                const filters = data.filters || [];

                // Update filters count badge
                const filtersCount = document.getElementById('filtersCount');
                if (filtersCount) {
                    filtersCount.textContent = filters.length;
                }

                const sessionFiltersList = document.getElementById('sessionFiltersList');
                if (sessionFiltersList) {
                    sessionFiltersList.innerHTML = '';

                    if (filters.length === 0) {
                        sessionFiltersList.innerHTML = '<li class="empty-filters">No filters applied yet</li>';
                        return;
                    }

                    // Render each filter
                    filters.forEach(filter => {
                        const li = document.createElement('li');
                        li.className = 'session-filter-item';

                        // Get display name and emoji from filter mapping
                        const filterInfo = filterMapping[filter.filter_type];
                        const displayName = filterInfo ? filterInfo.displayName : filter.filter_type;
                        const emoji = filterInfo ? filterInfo.emoji : '🎛️';

                        // Format time
                        const time = new Date(filter.applied_at).toLocaleTimeString([], {
                            hour: '2-digit',
                            minute: '2-digit'
                        });

                        li.innerHTML = `
                            <div class="filter-content">
                                <span class="filter-emoji">${emoji}</span>
                                <span class="filter-text">${displayName}</span>
                                <span class="filter-time">${time}</span>
                            </div>
                            <button class="delete-filter-btn" onclick="deleteSessionFilter(${filter.id})" title="Remove filter">
                                ×
                            </button>
                        `;
                        sessionFiltersList.appendChild(li);
                    });
                }
            } catch (error) {
                console.error('Error loading session filters:', error);
            }
        }

        async function deleteSessionFilter(filterId) {
            if (!currentUser) return;

            try {
                // Get current session to get the session ID
                const sessionResponse = await fetch(`/api/user/${currentUser.id}/sessions/current`);
                const sessionData = await sessionResponse.json();

                if (!sessionData.current_session) {
                    throw new Error('No active session found');
                }

                const sessionId = sessionData.current_session.id;

                // Delete the filter
                const response = await fetch(`/api/user/${currentUser.id}/sessions/${sessionId}/filters`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ filter_id: filterId })
                });

                const result = await response.json();

                if (result.error) {
                    throw new Error(result.error);
                }

                // Reload the filters list
                loadSessionFilters();

                console.log(`Filter ${filterId} deleted successfully`);
            } catch (error) {
                console.error('Error deleting session filter:', error);
                alert('Error removing filter. Please try again.');
            }
        }

        function formatValue(value) {
            if (typeof value === 'number') {
                return value.toFixed(2);
            }
            return value;
        }

        function updateTrackInfo(track) {
            // Update current track info in header
            const currentTrackInfo = document.getElementById('currentTrackInfo');
            currentTrackInfo.innerHTML = `
                <div class="track-name">${track.track_name || 'Unknown Track'}</div>
                <div class="track-artist">${track.artist_name || 'Unknown Artist'}</div>
                <div class="track-genre">${track.genre || 'Unknown Genre'}</div>
            `;

            // Update audio feature dials
            updateAudioDials(track);
        }

        function updateAudioDials(track) {
            const audioFeatures = [
                { 
                    key: 'danceability', 
                    value: track.danceability, 
                    emoji: '💃', 
                    label: 'Danceability',
                    color: 'dial-danceability'
                },
                { 
                    key: 'energy', 
                    value: track.energy, 
                    emoji: '⚡', 
                    label: 'Energy',
                    color: 'dial-energy'
                },
                { 
                    key: 'speechiness', 
                    value: track.speechiness, 
                    emoji: '🗣️', 
                    label: 'Speechiness',
                    color: 'dial-speechiness'
                },
                { 
                    key: 'valence', 
                    value: track.valence, 
                    emoji: '😊', 
                    label: 'Valence',
                    color: 'dial-valence'
                },
                {
                    key: 'tempo',
                    value: Math.min(track.tempo / 200, 1), // Normalize tempo to 0-1 scale
                    emoji: '🥁',
                    label: 'Tempo',
                    color: 'dial-tempo'
                },
                { 
                    key: 'acousticness', 
                    value: track.acousticness, 
                    emoji: '🎸', 
                    label: 'Acousticness',
                    color: 'dial-acousticness'
                },
                { 
                    key: 'instrumentalness', 
                    value: track.instrumentalness, 
                    emoji: '🎼', 
                    label: 'Instrumental',
                    color: 'dial-instrumentalness'
                },
                { 
                    key: 'liveness', 
                    value: track.liveness, 
                    emoji: '🎤', 
                    label: 'Liveness',
                    color: 'dial-liveness'
                }
            ];

            const dialsContainer = document.getElementById('audioDialsContainer');
            dialsContainer.innerHTML = audioFeatures.map(feature => {
                const percentage = Math.round(feature.value * 100);
                // Map 0-100% to 360° angle for conic-gradient
                const angle = feature.value * 360;

                // For tempo, show actual BPM in tooltip but use normalized percentage for dial
                let displayValue, tooltipValue;
                if (feature.key === 'tempo') {
                    displayValue = `${Math.round(track.tempo)} BPM`;
                    tooltipValue = `${feature.label}: ${displayValue} (${percentage}% of scale)`;
                } else {
                    displayValue = `${percentage}%`;
                    tooltipValue = `${feature.label}: ${displayValue}`;
                }

                return `
                    <div class="audio-dial" data-tooltip="${tooltipValue}">
                        <div class="dial-circle"></div>
                        <div class="dial-progress ${feature.color}"
                             style="--progress-angle: ${angle}deg;"></div>
                        <div class="dial-content">
                            <div class="dial-emoji">${feature.emoji}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function adjustPool(adjustment) {
            if (!currentUser) {
                console.error('No user authenticated for filter adjustment');
                return;
            }

            try {
                // Get current session ID from the backend
                const sessionResponse = await fetch(`/api/user/${currentUser.id}/sessions/current`);
                const sessionData = await sessionResponse.json();

                if (!sessionData.current_session || !sessionData.current_session.id) {
                    throw new Error('No active session found');
                }

                const sessionId = sessionData.current_session.id;

                // Apply filter to user session (this returns a track automatically)
                const response = await fetch(`/api/user/${currentUser.id}/sessions/${sessionId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ adjustment: parseInt(adjustment) })
                });

                const result = await response.json();

                if (result.error) {
                    throw new Error(result.error);
                }

                // The PUT endpoint returns a track directly
                if (result.track) {
                    currentTrackId = result.track.track_id;
                    renderPlayer(result.track);
                    updateTrackInfo(result.track);
                    updateLikeButton();
                } else {
                    throw new Error('No track returned from filter adjustment');
                }
            } catch (error) {
                console.error('Error adjusting pool:', error);
                if (error.message.includes('No active session')) {
                    window.location.href = '/sessions';
                }
            }
        }

        async function loadInitialTrack() {
            if (!currentUser) {
                console.log('No user authenticated yet, waiting...');
                return;
            }

            try {
                // Get current session to get the session ID
                const sessionResponse = await fetch(`/api/user/${currentUser.id}/sessions/current`);
                const sessionData = await sessionResponse.json();

                if (!sessionData.current_session) {
                    throw new Error('No active session found');
                }

                const sessionId = sessionData.current_session.id;
                const response = await fetch(`/api/user/${currentUser.id}/sessions/${sessionId}/track`);
                const track = await response.json();

                if (track.error) {
                    throw new Error(track.error);
                }

                currentTrackId = track.track_id;
                renderPlayer(track);
                updateTrackInfo(track);
                updateLikeButton();
                renderFilterButtons();
            } catch (error) {
                console.error('Error loading track:', error);
                if (error.message.includes('No active session')) {
                    // Redirect to sessions page if no active session
                    window.location.href = '/sessions';
                } else {
                    window.location.href = '/';
                }
            }
        }

        function toggleSidebar() {
            // This function would handle mobile sidebar toggle
            // For now, we'll redirect to a dedicated liked tracks page on mobile
            console.log('Sidebar toggle - could implement mobile modal here');
        }

        // Authentication functions
        async function checkAuthStatus() {
            try {
                const response = await fetch('/api/user');
                const data = await response.json();

                const userHeader = document.getElementById('userHeader');

                if (data.authenticated) {
                    currentUser = data.user;
                    // User is logged in
                    userHeader.innerHTML = `
                        <div class="user-info">
                            Welcome, <span class="user-name">${data.user.username}</span>
                        </div>
                        <button class="logout-btn" onclick="handleLogout()">Logout</button>
                    `;

                    // Now that user is authenticated, load initial track and liked tracks
                    loadInitialTrack();
                    loadLikedTracks();
                    loadSessionFilters();
                    initializePlaybackToggle();
                } else {
                    // User is not logged in, redirect to auth
                    window.location.href = '/auth';
                }
            } catch (error) {
                console.error('Error checking auth status:', error);
                // Redirect to auth on error
                window.location.href = '/auth';
            }
        }
        
        async function handleLogout() {
            try {
                const response = await fetch('/api/logout', {
                    method: 'POST'
                });
                
                if (response.ok) {
                    // Redirect to home page after logout
                    window.location.href = '/';
                }
            } catch (error) {
                console.error('Error logging out:', error);
            }
        }

        async function togglePlaybackType() {
            if (!currentUser) return;

            const toggle = document.getElementById('playbackToggle');
            const newPlaybackType = toggle.checked ? 'youtube' : 'spotify';

            try {
                const response = await fetch(`/api/user/${currentUser.id}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        playback_type: newPlaybackType
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    currentUser = result.user; // Update current user data
                    console.log(`Playback type changed to: ${newPlaybackType}`);

                    // Reload the current track with new playback type
                    await loadInitialTrack();
                } else {
                    console.error('Failed to update playback type');
                    // Revert toggle state
                    toggle.checked = currentUser.playback_type === 'youtube';
                }
            } catch (error) {
                console.error('Error updating playback type:', error);
                // Revert toggle state
                toggle.checked = currentUser.playback_type === 'youtube';
            }
        }

        function renderPlayer(track) {
            const spotifyEmbed = document.getElementById('spotifyEmbed');
            const youtubeEmbed = document.getElementById('youtubeEmbed');

            if (!currentUser) {
                console.error('No user data available for player rendering');
                return;
            }

            if (currentUser.playback_type === 'youtube' && track.youtube_video_id) {
                // Show YouTube player
                spotifyEmbed.style.display = 'none';
                youtubeEmbed.style.display = 'block';
                youtubeEmbed.src = `https://www.youtube.com/embed/${track.youtube_video_id}?si=dA-RzM4YTvZJgoRh&amp;controls=0&amp;start=60`;
                console.log(`Rendering YouTube player: ${track.youtube_video_id}`);
            } else {
                // Show Spotify player (default)
                youtubeEmbed.style.display = 'none';
                spotifyEmbed.style.display = 'block';
                spotifyEmbed.src = `https://open.spotify.com/embed/track/${track.track_id}?autoplay=1`;
                console.log(`Rendering Spotify player: ${track.track_id}`);
            }
        }

        function initializePlaybackToggle() {
            if (currentUser) {
                const toggle = document.getElementById('playbackToggle');
                toggle.checked = currentUser.playback_type === 'youtube';
            }
        }

        // Check auth status first, then load track after authentication
        checkAuthStatus();
    </script>
</body>
</html> 